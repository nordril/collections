<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Nordril.Collections</name>
    </assembly>
    <members>
        <member name="T:Nordril.Collections.AbstractStore`2">
            <summary>
            An abstract store which can be subclassed to obtain concrete stores.
            A store is a dictionary with an immutable/mutable-split: in its immutable version, it can only be read from, and one can make a mutable deep copy. This mutable deep copy can then be freely modified without affecting the original.
            </summary>
            <typeparam name="TKey">The key of the stored elements.</typeparam>
            <typeparam name="TValue">The elements which are stored.</typeparam>
        </member>
        <member name="P:Nordril.Collections.AbstractStore`2.Store">
            <summary>
            The underlying dictionary of values.
            </summary>
        </member>
        <member name="P:Nordril.Collections.AbstractStore`2.Copier">
            <summary>
            The copying-function for the store's values, in case a copy of the store is requested.
            </summary>
        </member>
        <member name="M:Nordril.Collections.AbstractStore`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Func{`1,`1})">
            <summary>
            Creates a new store with the supplied values <paramref name="values"/>. The values are copied via <paramref name="copier"/>.
            </summary>
            <param name="values">The values to put into the store.</param>
            <param name="copier">The copier which will be applied to every value, to store a copy in this store.</param>
        </member>
        <member name="M:Nordril.Collections.AbstractStore`2.#ctor(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1}},System.Func{`1,`1})">
            <summary>
            Creates a new store with the supplied values <paramref name="values"/>. The values are copied via <paramref name="copier"/>.
            </summary>
            <param name="values">The values to put into the store.</param>
            <param name="copier">The copier which will be applied to every value, to store a copy in this store.</param>
        </member>
        <member name="M:Nordril.Collections.AbstractStore`2.ContainsKey(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.AbstractStore`2.TryGetValue(`0,`1@)">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Collections.AbstractStore`2.Item(`0)">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Collections.AbstractStore`2.Keys">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Collections.AbstractStore`2.Values">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Collections.AbstractStore`2.Count">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.AbstractStore`2.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.AbstractStore`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.AbstractStore`2.Add(`0,`1)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.AbstractStore`2.AddMany(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.AbstractStore`2.CopyMutable">
            <summary>
            Creates a deep copy of the store.
            </summary>
            <remarks>
            Implementors can use the protected constructor of <see cref="T:Nordril.Collections.AbstractStore`2"/> to have the underlying dictionary copied.
            </remarks>
        </member>
        <member name="T:Nordril.Collections.Bijection`2">
            <summary>
            A bijection, i.e. a bidirectional directory.
            </summary>
            <typeparam name="TLeft">The type of the left keys.</typeparam>
            <typeparam name="TRight">The type of the right keys.</typeparam>
        </member>
        <member name="P:Nordril.Collections.Bijection`2.Item(`0)">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Collections.Bijection`2.Item(`1,Nordril.Functional.Data.TagRight)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.Bijection`2.ContainsRightKey(`1)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.Bijection`2.RemoveRight(`1)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.Bijection`2.TryGetLeftValue(`1,`0@)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.Bijection`2.Add(`0,`1)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.Bijection`2.ContainsKey(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.Bijection`2.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.Bijection`2.TryGetValue(`0,`1@)">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Collections.Bijection`2.Keys">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Collections.Bijection`2.Values">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.Bijection`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.Bijection`2.Clear">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.Bijection`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.Bijection`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.Bijection`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Collections.Bijection`2.Count">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Collections.Bijection`2.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.Bijection`2.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.Bijection`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Collections.DictionaryCache`2">
            <summary>
            A thread-safe dictionary-based cache with
            <list type="table">
                <listheader>
                    <term>Operation</term>
                    <description>Runtime</description>
                </listheader>
                
                <item>
                    <term>Retrieval of a non-cached element</term>
                    <description>O(1).</description>
                </item>
                <item>
                    <term>Retrieval of a cached element E</term>
                    <description>O(r) where r is the number of elements which were more recently accessed than E.</description>
                </item>
                <item>
                    <term>Removal of an old element due to cache-size limits</term>
                    <description>O(1).</description>
                </item>
                <item>
                    <term>Cache-resizing</term>
                    <description>O(max(m-n, n, 1)) where m is the old cache-size and n is the new cache size.</description>
                </item>
            </list>
            </summary>
            <typeparam name="TKey">The type of the keys.</typeparam>
            <typeparam name="TValue">The values to store.</typeparam>
        </member>
        <member name="M:Nordril.Collections.DictionaryCache`2.#ctor(System.Int32)">
            <summary>
            Creates a new <see cref="T:Nordril.Collections.DictionaryCache`2"/> with the specified cache size.
            </summary>
            <param name="cacheSize">The cache size.</param>
        </member>
        <member name="M:Nordril.Collections.DictionaryCache`2.SetCacheSize(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.DictionaryCache`2.RetrieveOrCache(`0,System.Func{`1},`1@)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.DictionaryCache`2.ContainsKey(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.DictionaryCache`2.TryGetValue(`0,`1@)">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Collections.DictionaryCache`2.Item(`0)">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Collections.DictionaryCache`2.Keys">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Collections.DictionaryCache`2.Values">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Collections.DictionaryCache`2.Count">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.DictionaryCache`2.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.DictionaryCache`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Collections.DictionaryExtensions">
            <summary>
            Extension methods for <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
        </member>
        <member name="M:Nordril.Collections.DictionaryExtensions.Update``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``1,``1})">
            <summary>
            Updates a value by applying <paramref name="f"/> if the key <paramref name="key"/> is present.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="dict">The dictionary to update.</param>
            <param name="key">The key.</param>
            <param name="f">The function to apply to the value.</param>
            <returns>true if <paramref name="f"/> was applied, false otherwise.</returns>
        </member>
        <member name="M:Nordril.Collections.DictionaryExtensions.AddToCollection``3(System.Collections.Generic.IDictionary{``0,``2},``0,``1)">
            <summary>
            Adds a new to a collection-valued dictionary, creating the key with a 1-element collection first if it doesn't exist.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the values, of which the dictionary contains collections.</typeparam>
            <typeparam name="TCollection">The type of the collection which stores the values.</typeparam>
            <param name="dict">The dictionary.</param>
            <param name="key">The key to which to add another value.</param>
            <param name="value">The value to associate with the key.</param>
        </member>
        <member name="M:Nordril.Collections.DictionaryExtensions.AddToSet``3(System.Collections.Generic.IDictionary{``0,``2},``0,``1)">
            <summary>
            Adds a new to a set-valued dictionary, creating the key with a 1-element set first if it doesn't exist.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the values, of which the dictionary contains sets.</typeparam>
            <typeparam name="TSet">The type of the set which stores the values.</typeparam>
            <param name="dict">The dictionary.</param>
            <param name="key">The key to which to add another value.</param>
            <param name="value">The value to associate with the key.</param>
            <returns>true if the value was not already present in the set associated with the key, false otherwise.</returns>
        </member>
        <member name="M:Nordril.Collections.DictionaryExtensions.Update``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1,System.Func{``1,``1})">
            <summary>
            Updates a value by applying <paramref name="f"/> if the key <paramref name="key"/> is present. If not, <paramref name="def"/> is inserted.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="dict">The dictionary to update.</param>
            <param name="key">The key.</param>
            <param name="def">The default value to insert if the key was not present.</param>
            <param name="f">The function to apply to the value.</param>
            <returns>true if <paramref name="f"/> was applied, false otherwise.</returns>
        </member>
        <member name="M:Nordril.Collections.DictionaryExtensions.MapValues``2(System.Collections.Generic.IDictionary{``0,``1},System.Func{``1,``1})">
            <summary>
            Applies <paramref name="f"/> to all values in a dictionary.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="dict">The dictionary to update.</param>
            <param name="f">The function to apply to the value.</param>
        </member>
        <member name="M:Nordril.Collections.DictionaryExtensions.MapValuesWithKey``2(System.Collections.Generic.IDictionary{``0,``1},System.Func{``0,``1,``1})">
            <summary>
            Applies <paramref name="f"/> to all values in a dictionary.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="dict">The dictionary to update.</param>
            <param name="f">The function to apply to the value.</param>
        </member>
        <member name="T:Nordril.Collections.IBijection`2">
            <summary>
            A finite, 1:1 mapping between values.
            </summary>
            <typeparam name="TLeft">The left value.</typeparam>
            <typeparam name="TRight">The right value.</typeparam>
        </member>
        <member name="P:Nordril.Collections.IBijection`2.Item(`0)">
            <summary>
            Gets or sets the right key associated with the left key.
            </summary>
            <param name="key">The right key associated with the left key.</param>
            <exception cref="T:System.ArgumentNullException">key is null.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is retrieved and the key is not found.</exception>
            <exception cref="T:Nordril.Collections.KeyAlreadyPresentException">The property was set, but the value was already associated with another left value.</exception>
        </member>
        <member name="P:Nordril.Collections.IBijection`2.Item(`1,Nordril.Functional.Data.TagRight)">
            <summary>
            Gets or sets the left key associated with the right key.
            </summary>
            <param name="key">The right key associated with the left key.</param>
            <param name="tag">A type-level tag to resolve ambiguity with indexer of <see cref="T:System.Collections.Generic.IDictionary`2"/>.</param>
            <exception cref="T:System.ArgumentNullException">key is null.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is retrieved and the key is not found.</exception>
            <exception cref="T:Nordril.Collections.KeyAlreadyPresentException">The property was set, but the value was already associated with another right value.</exception>
        </member>
        <member name="M:Nordril.Collections.IBijection`2.ContainsRightKey(`1)">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.IDictionary`2"/> contains an element
            with the specified right key. This is the efficient version of <see cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/>
            which uses indexing.
            </summary>
            <param name="key">The key to locate.</param>
        </member>
        <member name="M:Nordril.Collections.IBijection`2.RemoveRight(`1)">
            <summary>
            Removes the element with the specified right key from the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <param name="key">The key of the element to remove.</param>
        </member>
        <member name="M:Nordril.Collections.IBijection`2.TryGetLeftValue(`1,`0@)">
            <summary>
            Gets the left key associated with the specified right key.
            </summary>
            <param name="key">The right key whose associated left key to get.</param>
            <param name="value">The left key, if present; otherwise, the type's default value is returned.</param>
        </member>
        <member name="T:Nordril.Collections.IDictionaryCache`2">
            <summary>
            A dictionary-based, thread-safe cache which uses a least-recently-used (LRU) caching strategy for its keys.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:Nordril.Collections.IDictionaryCache`2.SetCacheSize(System.Int32)">
            <summary>
            Sets the maximum cache size. No more entries than <paramref name="size"/> will be stored. If the <see cref="T:Nordril.Collections.IDictionaryCache`2"/> contains more than <paramref name="size"/> elements at the time of this call, the oldest elements will be purged first, until the following holds:
            <code>
               this.Count == size
            </code>
            </summary>
            <param name="size">The maximum size of the cahce.</param>
            <exception cref="T:Nordril.Collections.NegativeSizeException">If <paramref name="size"/> is negative.</exception>
        </member>
        <member name="M:Nordril.Collections.IDictionaryCache`2.RetrieveOrCache(`0,System.Func{`1},`1@)">
            <summary>
            Either retrieves the cached value for a key or registers a new value <paramref name="newValue"/> and returns that.
            </summary>
            <param name="key">The key whose value to retrieve.</param>
            <param name="newValue">The factory for the new value, which is called if the key isn't found and the result of which is registered if the key isn't found.</param>
            <param name="value">The value to return.</param>
            <returns>The result of the caching operation.</returns>
        </member>
        <member name="T:Nordril.Collections.CacheResult">
            <summary>
            The result of a caching operation (trying to retrieve an item from cache and optionally entering it into the cache).
            </summary>
        </member>
        <member name="F:Nordril.Collections.CacheResult.WasFoundCached">
            <summary>
            The element was present in cache and the cached value was returned.
            </summary>
        </member>
        <member name="F:Nordril.Collections.CacheResult.WasInserted">
            <summary>
            The element was not present and a fresh value was inserted into the cache.
            </summary>
        </member>
        <member name="F:Nordril.Collections.CacheResult.WasMissingAndNotCached">
            <summary>
            The element was not present, but a new value was not cahced due to cache limitations.
            </summary>
        </member>
        <member name="T:Nordril.Collections.IPartialMatchSearchable`2">
            <summary>
            A data structure that supports search based on partial queries. A partial query is one which only specifies a subset of the data structure's key to be a certain value.
            </summary>
            <typeparam name="TKey">The type of the structure's key parts. The keys are composed of an array of key parts.</typeparam>
            <typeparam name="TValue">The type of the structure's values.</typeparam>
        </member>
        <member name="P:Nordril.Collections.IPartialMatchSearchable`2.Dimensions">
            <summary>
            Returns the number of parts of which the keys of the items are composed.
            </summary>
        </member>
        <member name="M:Nordril.Collections.IPartialMatchSearchable`2.GetValueByPartialQuery(System.Collections.Generic.IDictionary{System.Int32,`0})">
            <summary>
            Finds all items which match the partial query <paramref name="query"/>. An item <code>X</code> is presumed to have an ordered, 0-indexed list of key-parts and it matches the query <code>query = {(k_1 -&gt; v_1),...,(k_n -&gt; v_n)}</code> iff, for all <code> i in {1,...,n}, value_of_keypart(k_i, X) = v_i</code>.
            <br />
            As special cases, this means that a query which has values for all key parts is analogous <see cref="M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)"/> (an exact match), and a query which has no values specified is analogous to <see cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/> (getting all stored values).
            </summary>
            <param name="query">The query to match against the structure. The keys are the indexes of the key parts and the values are the values which those key parts have to have.</param>
        </member>
        <member name="M:Nordril.Collections.IPartialMatchSearchable`2.GetValueByPartialQuery(System.ValueTuple{System.Int32,`0}[])">
            <summary>
            See <see cref="M:Nordril.Collections.IPartialMatchSearchable`2.GetValueByPartialQuery(System.Collections.Generic.IDictionary{System.Int32,`0})"/>.
            </summary>
            <param name="query">The query to match against the structure.</param>
        </member>
        <member name="T:Nordril.Collections.IReadOnlyStore`2">
            <summary>
            A read-only store which has the same interface as a dictionary, but which can create mutable copies of itself.
            </summary>
            <typeparam name="TKey">The key of the stored elements.</typeparam>
            <typeparam name="TValue">The elements which are stored.</typeparam>
        </member>
        <member name="M:Nordril.Collections.IReadOnlyStore`2.CopyMutable">
            <summary>
            Creates a mutable copy of this store.
            </summary>
        </member>
        <member name="T:Nordril.Collections.IStore`2">
            <summary>
            A mutable store which has the same interface as a dictionary and which can be copied.
            </summary>
            <typeparam name="TKey">The keys of the stored elements.</typeparam>
            <typeparam name="TValue">The elements which are stored.</typeparam>
        </member>
        <member name="M:Nordril.Collections.IStore`2.Add(`0,`1)">
            <summary>
            Adds a new entry to the store.
            </summary>
            <param name="key">The key of the new element.</param>
            <param name="value">The value of the new element.</param>
        </member>
        <member name="M:Nordril.Collections.IStore`2.AddMany(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1}})">
            <summary>
            Adds many entries to the store at once. Depending on the implemention, this
            operation may be more efficient than repeatedly calling <see cref="M:Nordril.Collections.IStore`2.Add(`0,`1)"/>.
            </summary>
            <param name="values">The elements to add.</param>
        </member>
        <member name="T:Nordril.Collections.KeyAlreadyPresentException">
            <summary>
            Indicates that a string-key was already present when an attempt was made to
            insert it into a collection.
            </summary>
        </member>
        <member name="P:Nordril.Collections.KeyAlreadyPresentException.Key">
            <summary>
            The key or its string-form.
            </summary>
        </member>
        <member name="M:Nordril.Collections.KeyAlreadyPresentException.#ctor(System.String)">
            <summary>
            Creates a new exception.
            </summary>
            <param name="key">The value of the duplicate key.</param>
        </member>
        <member name="M:Nordril.Collections.KeyAlreadyPresentException.#ctor">
            <summary>
            Creates a new exception.
            </summary>
        </member>
        <member name="M:Nordril.Collections.KeyAlreadyPresentException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new exception.
            </summary>
            <param name="message">The error message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="T:Nordril.Collections.KeyNotPresentException">
            <summary>
            Indicates that a string-key was not present when an attempt was made to
            delete it from a collection.
            </summary>
        </member>
        <member name="P:Nordril.Collections.KeyNotPresentException.Key">
            <summary>
            The key or its string-form.
            </summary>
        </member>
        <member name="M:Nordril.Collections.KeyNotPresentException.#ctor(System.String)">
            <summary>
            Creates a new <see cref="T:Nordril.Collections.KeyNotPresentException"/>.
            </summary>
            <param name="key">The value of the duplicate key.</param>
        </member>
        <member name="M:Nordril.Collections.KeyNotPresentException.#ctor">
            <summary>
            Creates a new <see cref="T:Nordril.Collections.KeyNotPresentException"/>
            </summary>
        </member>
        <member name="M:Nordril.Collections.KeyNotPresentException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new <see cref="T:Nordril.Collections.KeyNotPresentException"/> with a custom error message and an inner exception.
            </summary>
            <param name="message">The error message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="T:Nordril.Collections.ListExtensions">
            <summary>
            Extension methods for <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Collections.ListExtensions.BinarySearchIndexOf``2(System.Collections.Generic.IList{``0},``1,System.Func{``1,``1,System.Int32},System.Func{``0,``1})">
            <summary>
            Performs a lookup of an element using binary search. The element's index, if present, is returned.
            </summary>
            <typeparam name="TOuter">The type of elements in the list.</typeparam>
            <typeparam name="T">The type of the elements by which to look up.</typeparam>
            <param name="xs">The list to search.</param>
            <param name="elem">The element to look up.</param>
            <param name="comparer">The comparison function. Negative values indicate "the first argument is smaller than the second", 0 indicates "the arguments are equal" and positive values indicate "the first argument is larger than the second".</param>
            <param name="selector">The selector to apply to the elements. If null, no selector is used.</param>
        </member>
        <member name="M:Nordril.Collections.ListExtensions.BinarySearchIndexOf``2(System.Collections.Generic.IList{``0},``1,System.Func{``0,``1})">
            <summary>
            Performs a lookup of an element using binary search and the <see cref="T:System.IComparable`1"/>-implementation to guide it.
            </summary>
            <typeparam name="TOuter">The type of elements in the list.</typeparam>
            <typeparam name="T">The type of the elements by which to look up.</typeparam>
            <param name="xs">The list of search.</param>
            <param name="elem">The element to look up.</param>
            <param name="selector">The selector to apply to the elements. If null, no selector is used.</param>
        </member>
        <member name="M:Nordril.Collections.ListExtensions.BinarySearchIndexOfApproximate``2(System.Collections.Generic.IList{``0},``1,System.Func{``1,``1,System.Int32},System.Int32,System.Func{``0,``1})">
            <summary>
            Performs a lookup of an element using binary search. The element's index, if present, is returned. If the element isn't found, <paramref name="roundingDirection"/> can be used to return its nearest left or right closest match.
            </summary>
            <typeparam name="TOuter">The type of elements in the list.</typeparam>
            <typeparam name="T">The type of the elements by which to look up.</typeparam>
            <param name="xs">The list to search.</param>
            <param name="elem">The element to look up.</param>
            <param name="comparer">The comparison function. Negative values indicate "the first argument is smaller than the second", 0 indicates "the arguments are equal" and positive values indicate "the first argument is larger than the second".</param>
            <param name="roundingDirection">The rounding direction. 0 means "no rounding allowed". Positive values mean "if there's no exact match, get the next larger element, if present" and negative values mean "if there's no exact match, get the next smaller value, if present".</param>
            <param name="selector">The selector to apply to the elements. If null, no selector is used.</param>
        </member>
        <member name="M:Nordril.Collections.ListExtensions.BinarySearchIndexOfApproximate``2(System.Collections.Generic.IList{``0},``1,System.Int32,System.Func{``0,``1})">
            <summary>
            Performs a lookup of an element using binary search  and the <see cref="T:System.IComparable`1"/>-implementation to guide it. The element's index, if present, is returned. If the element isn't found, <paramref name="roundingDirection"/> can be used to return its nearest left or right closest match.
            </summary>
            <typeparam name="TOuter">The type of elements in the list.</typeparam>
            <typeparam name="T">The type of the elements by which to look up.</typeparam>
            <param name="xs">The list to search.</param>
            <param name="elem">The element to look up.</param>
            <param name="roundingDirection">The rounding direction. 0 means "no rounding allowed". Positive values mean "if there's no exact match, get the next larger element, if present" and negative values mean "if there's no exact match, get the next smaller value, if present".</param>
            <param name="selector">The selector to apply to the elements. If null, no selector is used.</param>
        </member>
        <member name="T:Nordril.Collections.MethodCache.ListCache">
            <summary>
            A cache of typed constructors for <see cref="T:System.Collections.Generic.List`1"/>. This is useful if you have value-level types (<see cref="T:System.Type"/>) and dynamically want to call the <see cref="T:System.Collections.Generic.List`1"/>-constructor with them as type argument.
            This class uses dynamic method compilation to provide high-performance access to the constructor of <see cref="T:System.Collections.Generic.List`1"/>, avoiding the high, repeated runtime cost of reflection.
            </summary>
        </member>
        <member name="M:Nordril.Collections.MethodCache.ListCache.#ctor(System.Int32)">
            <summary>
            Creates a new cache.
            </summary>
            <param name="cacheSize">The maximum cache size.</param>
        </member>
        <member name="M:Nordril.Collections.MethodCache.ListCache.RetrieveOrCacheCreate``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Retrieves the <see cref="T:Nordril.Functional.Data.FuncList`1"/>-constructor and caches itfor type <typeparamref name="T"/>.
            </summary>
            <param name="elements">The list of elements.</param>
            <typeparam name="T">The type of the contents.</typeparam>
        </member>
        <member name="M:Nordril.Collections.MethodCache.ListCache.RetrieveOrCacheCreate(System.Type,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Retrieves the <see cref="T:Nordril.Functional.Data.FuncList`1"/>-constructor and caches itfor type <paramref name="t"/>.
            </summary>
            <param name="elements">The list of elements.</param>
            <param name="t">The type of the contents.</param>
        </member>
        <member name="T:Nordril.Collections.MethodCache.MaybeCache">
            <summary>
            A cache of typed constructors for <see cref="T:Nordril.Functional.Data.Maybe`1"/>. This is useful if you have value-level types (<see cref="T:System.Type"/>) and dynamically want to call <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/>/<see cref="M:Nordril.Functional.Data.Maybe.Just``1(``0)"/> with them as type argument.
            This class uses dynamic method compilation to provide high-performance access to the constructors of <see cref="T:Nordril.Functional.Data.Maybe"/>, avoiding the high, repeated runtime cost of reflection.
            </summary>
        </member>
        <member name="M:Nordril.Collections.MethodCache.MaybeCache.#ctor(System.Int32)">
            <summary>
            Creates a new cache.
            </summary>
            <param name="cacheSize">The maximum cache size.</param>
        </member>
        <member name="M:Nordril.Collections.MethodCache.MaybeCache.RetrieveOrCacheNothing``1">
            <summary>
            Retrieves <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/>-method and caches both <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/> and <see cref="M:Nordril.Functional.Data.Maybe.Just``1(``0)"/> for type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of the contents.</typeparam>
        </member>
        <member name="M:Nordril.Collections.MethodCache.MaybeCache.RetrieveOrCacheJust``1(``0)">
            <summary>
            Retrieves <see cref="M:Nordril.Functional.Data.Maybe.Just``1(``0)"/>-method and caches both <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/> and <see cref="M:Nordril.Functional.Data.Maybe.Just``1(``0)"/> for type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of the contents.</typeparam>
        </member>
        <member name="M:Nordril.Collections.MethodCache.MaybeCache.RetrieveOrCacheNothing(System.Type)">
            <summary>
            Retrieves <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/>-method and caches both <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/> and <see cref="M:Nordril.Functional.Data.Maybe.Just``1(``0)"/> for type <paramref name="t"/>.
            </summary>
            <param name="t">The type of the contents.</param>
        </member>
        <member name="M:Nordril.Collections.MethodCache.MaybeCache.RetrieveOrCacheJust(System.Type,System.Object)">
            <summary>
            Retrieves <see cref="M:Nordril.Functional.Data.Maybe.Just``1(``0)"/>-method and caches both <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/> and <see cref="M:Nordril.Functional.Data.Maybe.Just``1(``0)"/> for type <paramref name="t"/>.
            </summary>
            <param name="t">The type of the contents.</param>
            <param name="value">The contents.</param>
        </member>
        <member name="T:Nordril.Collections.MethodCache.ResultCache">
            <summary>
            A cache of typed constructors for <see cref="T:Nordril.Base.Result`1"/>. This is useful if you have value-level types (<see cref="T:System.Type"/>) and dynamically want to call <see cref="M:Nordril.Base.Result.Ok``1(``0)"/>/<see cref="M:Nordril.Base.Result.WithErrors``1(System.Collections.Generic.IEnumerable{Nordril.Base.Error},Nordril.Base.ResultClass)"/> with them as type argument.
            This class uses dynamic method compilation to provide high-performance access to the constructors of <see cref="T:Nordril.Base.Result"/>, avoiding the high, repeated runtime cost of reflection.
            </summary>
        </member>
        <member name="M:Nordril.Collections.MethodCache.ResultCache.#ctor(System.Int32)">
            <summary>
            Creates a new cache.
            </summary>
            <param name="cacheSize">The maximum cache size.</param>
        </member>
        <member name="M:Nordril.Collections.MethodCache.ResultCache.RetrieveOrCacheWithErrors``1(System.Collections.Generic.IEnumerable{Nordril.Base.Error},Nordril.Base.ResultClass)">
            <summary>
            Retrieves <see cref="M:Nordril.Base.Result.Ok``1(``0)"/>-method and caches both both methods for type <typeparamref name="T"/>.
            </summary>
            <param name="errors">The list of errors.</param>
            <param name="rc">The <see cref="T:Nordril.Base.ResultClass"/>.</param>
            <typeparam name="T">The type of the contents.</typeparam>
        </member>
        <member name="M:Nordril.Collections.MethodCache.ResultCache.RetrieveOrCacheOk``1(``0)">
            <summary>
            Retrieves <see cref="M:Nordril.Base.Result.Ok``1(``0)"/>-method and caches both methods for type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of the contents.</typeparam>
        </member>
        <member name="M:Nordril.Collections.MethodCache.ResultCache.RetrieveOrCacheWithErrors(System.Type,System.Collections.Generic.IEnumerable{Nordril.Base.Error},Nordril.Base.ResultClass)">
            <summary>
            Retrieves <see cref="M:Nordril.Base.Result.WithErrors``1(System.Collections.Generic.IEnumerable{Nordril.Base.Error},Nordril.Base.ResultClass)"/>-method and caches both both methods for type <paramref name="t"/>.
            </summary>
            <param name="errors">The list of errors.</param>
            <param name="rc">The <see cref="T:Nordril.Base.ResultClass"/>.</param>
            <param name="t">The type of the contents.</param>
        </member>
        <member name="M:Nordril.Collections.MethodCache.ResultCache.RetrieveOrCacheOk(System.Type,System.Object)">
            <summary>
            Retrieves <see cref="M:Nordril.Base.Result.WithErrors``1(System.Collections.Generic.IEnumerable{Nordril.Base.Error},Nordril.Base.ResultClass)"/>-method and caches both both methods for type <paramref name="t"/>.
            </summary>
            <param name="value">The result.</param>
            <param name="t">The type of the contents.</param>
        </member>
        <member name="T:Nordril.Collections.NegativeSizeException">
            <summary>
            Indicates that an invalid, negative size was passed as a parameter into a container.
            </summary>
        </member>
        <member name="P:Nordril.Collections.NegativeSizeException.Key">
            <summary>
            The key or its string-form.
            </summary>
        </member>
        <member name="M:Nordril.Collections.NegativeSizeException.#ctor(System.String)">
            <summary>
            Creates a new <see cref="T:Nordril.Collections.NegativeSizeException"/>.
            </summary>
            <param name="key">The value of the duplicate key.</param>
        </member>
        <member name="M:Nordril.Collections.NegativeSizeException.#ctor">
            <summary>
            Creates a new <see cref="T:Nordril.Collections.NegativeSizeException"/>
            </summary>
        </member>
        <member name="M:Nordril.Collections.NegativeSizeException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new <see cref="T:Nordril.Collections.NegativeSizeException"/> with a custom error message and an inner exception.
            </summary>
            <param name="message">The error message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="T:Nordril.Collections.ValueDictionary`2">
            <summary>
            A wrapper around an arbitrary <see cref="T:System.Collections.Generic.IDictionary`2"/> which determines equality based on the contained keys and values instead of by reference. Two <see cref="T:Nordril.Collections.ValueDictionary`2"/>-object are equal if they contain the same set of keys and, for every contained key, <see cref="M:System.Object.Equals(System.Object)"/> of the corresponding values returns true.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
        </member>
        <member name="F:Nordril.Collections.ValueDictionary`2.dict">
            <summary>
            The underlying dictionary field, which <see cref="P:Nordril.Collections.ValueDictionary`2.Dict"/> returns.
            </summary>
        </member>
        <member name="P:Nordril.Collections.ValueDictionary`2.Dict">
            <summary>
            The underlying dictionary.
            </summary>
        </member>
        <member name="M:Nordril.Collections.ValueDictionary`2.Add(`0,`1)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.ValueDictionary`2.ContainsKey(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.ValueDictionary`2.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.ValueDictionary`2.TryGetValue(`0,`1@)">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Collections.ValueDictionary`2.Item(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.ValueDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Creates a new <see cref="T:Nordril.Collections.ValueDictionary`2"/> from a pair of keys and values.
            </summary>
            <param name="pairs">The pairs to put into the dictionary.</param>
        </member>
        <member name="M:Nordril.Collections.ValueDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1}})">
            <summary>
            Creates a new <see cref="T:Nordril.Collections.ValueDictionary`2"/> from a pair of keys and values.
            </summary>
            <param name="pairs">The pairs to put into the dictionary.</param>
        </member>
        <member name="P:Nordril.Collections.ValueDictionary`2.Keys">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Collections.ValueDictionary`2.Values">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.ValueDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.ValueDictionary`2.Clear">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.ValueDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.ValueDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.ValueDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Collections.ValueDictionary`2.Count">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Collections.ValueDictionary`2.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.ValueDictionary`2.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.ValueDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Collections.ValueDictionary`2.Equals(Nordril.Collections.ValueDictionary{`0,`1})">
            <summary>
            Determines equality based on the contents of two <see cref="T:Nordril.Collections.ValueDictionary`2"/>-objects. Two objects are equal if they have the same set of keys and if, for every contained key, <see cref="M:System.IEquatable`1.Equals(`0)"/> of the values returns true.
            </summary>
            <param name="other">The other <see cref="T:Nordril.Collections.ValueDictionary`2"/>.</param>
        </member>
        <member name="M:Nordril.Collections.ValueDictionary`2.Equals(System.Object)">
            <summary>
            See <see cref="M:Nordril.Collections.ValueDictionary`2.Equals(Nordril.Collections.ValueDictionary{`0,`1})"/>.
            </summary>
            <param name="obj">The other oject.</param>
        </member>
        <member name="M:Nordril.Collections.ValueDictionary`2.op_Equality(Nordril.Collections.ValueDictionary{`0,`1},Nordril.Collections.ValueDictionary{`0,`1})">
            <summary>
            See <see cref="M:Nordril.Collections.ValueDictionary`2.Equals(Nordril.Collections.ValueDictionary{`0,`1})"/>.
            </summary>
            <param name="left">The first object.</param>
            <param name="right">The second object.</param>
        </member>
        <member name="M:Nordril.Collections.ValueDictionary`2.op_Inequality(Nordril.Collections.ValueDictionary{`0,`1},Nordril.Collections.ValueDictionary{`0,`1})">
            <summary>
            See <see cref="M:Nordril.Collections.ValueDictionary`2.Equals(Nordril.Collections.ValueDictionary{`0,`1})"/>.
            </summary>
            <param name="left">The first object.</param>
            <param name="right">The second object.</param>
        </member>
        <member name="M:Nordril.Collections.ValueDictionary`2.GetHashCode">
            <summary>
            Computes the hash based on <see cref="M:Nordril.Functional.CollectionExtensions.HashElements``1(System.Collections.Generic.IEnumerable{``0})"/>.
            </summary>
        </member>
    </members>
</doc>
